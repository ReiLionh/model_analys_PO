# Маслинская Мария

# МДК.03.01
# Моделирование и анализ программного обеспечения

*Главная цель* — создать понятную, непротиворечивую и полную модель будущей или существующей системы до или в процессе её реализации, чтобы снизить риски, стоимость ошибок и улучшить коммуникацию между заказчиками, аналитиками и разработчиками.

*МДК 03.01* — это дисциплина, которая формирует инженерное мышление у программиста, переводя его деятельность с уровня «написания кода» на уровень проектирования и анализа программных продуктов.

*Анализ требований* — процесс выявления, документирования и согласования потребностей заказчика и ограничений системы.

*Модель* — упрощённое представление системы, описывающее её структуру (из чего состоит) и поведение (как работает).

`Моделирование ПО — создание упрощённого представления (модели) системы для изучения её структуры, поведения или свойств до реализации.`

`Анализ ПО — систематическое исследование модели или кода для выявления ошибок, проверки соответствия требованиям и оценки характеристик (надёжность, безопасность, производительность).`

#### Главные отличия:
- При моделировании проектируется будущая система;
- При анализе проверяется уже существующая система или объект.

*Артефакт* — конкретный результат анализа (документ, диаграмма, прототип). Н-р, ТЗ, UML-диаграммы.

*Стейкхолдеры* (заинтересованные лица) — все, кто влияет на систему или на кого она влияет (заказчик, пользователь).

#### Результат компетенции:
- Читать и создавать ТЗ;
- Переводить разговорные требования в формальные схемы;
- Находить противоречия и тупики в логике до программирования;
- Обслуживать проект с заказчиком, аналитиком на одном языке.

#### Области применения:
- Авиация, космос, анализ моделей для гарантии безопасности;
- Медицина;
- Финтех и телеком (анализ на корректность и отсутствие уязвимостей);
- Разработка сложных распределительных систем (моделирование взаимодействий до реализации, моделирование процессов развёртывания и отказоустойчивости).

---

## Задачи и методы моделирования и анализа программных продуктов

### Выбор критериев сравнения
Это начальный этап любого сравнения, на котором определяется, по каким параметрам будет оцениваться программный продукт. Критерии должны быть релевантными, измеримыми и объективными. 
Например, для сравнения баз данных могут использоваться критерии производительности (скорость запросов), масштабируемость, поддержка стандартов SQL, стоимость лицензии и качество документации. Правильный выбор критериев напрямую влияет на обоснованность и полезность итогового вывода.

### Работа с проектной документацией, разработанной с использованием графических языков спецификаций
Графические языки, такие как UML или BPMN, предоставляют стандартизированный способ визуального представления архитектуры и процессов системы. Работа с такой документацией включает в себя не только ее чтение, но и критический анализ на полноту, непротиворечивость и соответствие требованиям. 
Умение правильно интерпретировать диаграммы классов, последовательностей или развертывания позволяет быстро вникать в логику чужого проекта и эффективно вносить изменения.

### Сравнительный анализ средств просмотра видео
Это практический пример применения методологии сравнительного анализа. В процессе оцениваются такие параметры, как поддержка разнообразных кодеков и форматов (MKV, MP4, AVI), качество рендеринга и масштабирования видео, удобство пользовательского интерфейса, потребление оперативной памяти и процессорного времени, а также наличие дополнительных функций, таких как создание скриншотов, эквалайзер звука или поддержка плагинов. Результат помогает выбрать оптимальный инструмент для конкретной задачи или пользовательской среды.

### Применение обратного проектирования и проведение анализа потоков данных
Обратное проектирование (reverse engineering) — это процесс анализа конечного продукта (например, исполняемого файла) для воссоздания его архитектуры, логики работы или исходного кода. Часто применяется для интеграции с legacy-системами, документирования устаревшего кода или анализа безопасности. 
Анализ потоков данных (Data Flow Analysis, DFA) является методом статического анализа, который отслеживает возможные значения переменных и их передачу через программу. Это помогает обнаружить такие ошибки, как использование неинициализированных переменных или утечки конфиденциальных данных.

### Создание и изучение возможностей репозитория проекта
Современная разработка немыслима без систем контроля версий (VCS). Создание репозитория — это не просто инициализация git init. Это формирование структуры проекта (например, выбор между монолитом или монорепозиторием), настройка правил ветвления (Git Flow, GitHub Flow), определение политик доступа и интеграция с системами непрерывной интеграции (CI/CD). 
Изучение возможностей репозитория позволяет команде эффективно управлять изменениями, отслеживать историю правок, совместно работать над кодом без конфликтов и быстро восстанавливать предыдущие версии проекта при необходимости. Это основа для контролируемой и предсказуемой разработки в командной среде.

### Сравнительный анализ браузеров
В данном контексте анализ браузеров — это комплексное исследование, выходящее за рамки субъективных предпочтений. Ключевые критерии включают скорость выполнения JavaScript и рендеринга страниц (измеряется с помощью бенчмарков), уровень безопасности (частота и скорость закрытия уязвимостей), соответствие веб-стандартам (HTML5, CSS3), потребление оперативной памяти и энергии, а также экосистему расширений. 
Такой анализ важен как для рядовых пользователей, так и для веб-разработчиков, которым необходимо обеспечить кросс-браузерную совместимость своих продуктов.

### Механизмы и контроль внесения изменений в код
Контроль изменений — это совокупность процессов и инструментов, обеспечивающих целостность и качество кодовой базы. Основные механизмы включают обязательный код-ревью (pull/merge request), где изменения проверяются коллегами, запуск автоматизированных тестовых пайплайнов перед слиянием, требование прохождения статического анализа и соответствия стилю кодирования. 
Такие практики предотвращают попадание ошибок в основную ветку, способствуют распространению знаний в команде и поддерживают высокий стандарт качества кода.

### Анализ потоков данных
Как метод статического анализа, анализ потоков данных исследует, как значения переменных и информации передаются и трансформируются между различными точками программы. Он строится на графе потока управления (CFG) программы. 
Этот анализ позволяет решать такие задачи, как определение возможных значений переменных в каждой точке, удаление "мертвого" (никогда не используемого) кода, распространение констант и, что особенно важно, выявление потенциальных уязвимостей безопасности, например, когда непроверенные пользовательские данные попадают в критически важные функции.

### Дизассемблирование
Дизассемблирование — это процесс преобразования машинного кода (бинарного исполняемого файла) обратно в код на ассемблере, который гораздо ближе к человеко-читаемому виду. Это ключевой этап обратного проектирования. Инструменты вроде IDA Pro, Ghidra или Radare2 не только выполняют дизассемблирование, но и помогают аналитику структурировать код, выделять функции, переименовывать переменные и оставлять комментарии. 
Этот процесс используется для анализа вредоносного ПО, поиска уязвимостей в коммерческих продуктах или восстановления логики работы программ, исходный код которых утерян.

### Экспорт настроек в командной среде разработки
Для обеспечения консистентности среды разработки внутри команды необходимо унифицировать настройки IDE (IntelliJ IDEA, Visual Studio Code, Eclipse). Это включает в себя экспорт и импорт профилей, содержащих настройки форматирования кода, шаблоны файлов, конфигурации запуска, наборы плагинов и их параметры. 
Такой подход минимизирует проблемы типа "а у меня работает", ускоряет адаптацию новых разработчиков и позволяет быстро восстанавливать рабочее окружение в случае сбоя.

### Примеры сравнительного анализа программных продуктов
Практические примеры закрепляют теорию. Сравнение может проводиться между:
- Системами управления контентом (CMS): WordPress, Joomla, Drupal по критериям удобства администрирования, безопасности, наличию тем и модулей.
- Базами данных: PostgreSQL, MySQL, MongoDB по критериям согласованности данных, производительности при различных нагрузках, поддержке специфических типов данных.
- Фреймворками для веб-разработки: Django, Ruby on Rails, Laravel по критериям скорости разработки, производительности, безопасности "из коробки".
Каждый пример демонстрирует, как применять выбранные критерии на практике и взвешивать компромиссы.

### Обратное проектирование
Более глубокий взгляд на обратное проектирование как дисциплину. Оно может преследовать различные цели: Анализ взаимодействия для создания совместимого ПО, Восстановление документации для устаревших систем, Исследование безопасности для поиска уязвимостей или проверки на наличие бэкдоров, Академический анализ алгоритмов. Процесс часто включает не только дизассемблирование, но и декомпиляцию (попытку восстановления исходного кода на высокоуровневом языке), отладку и трассировку выполнения программы.

### Методы организации работы в команде разработчиков
Речь идет о методологиях и фреймворках управления проектами. 
Agile — это семейство гибких итеративных подходов. Scrum (в рамках Agile) структурирует работу в короткие спринты с ролями Scrum Master и Product Owner. Kanban фокусируется на визуализации потока задач и ограничении Work in Progress (WIP). 
Waterfall (каскадная модель) предполагает строго последовательное выполнение этапов: сбор требований, проектирование, реализация, тестирование, внедрение. Выбор метода зависит от стабильности требований, размера команды и специфики проекта.

### Сравнительный анализ офисных пакетов
Это классический пример бизнес-ориентированного сравнения. Анализируются такие пакеты, как проприетарный Microsoft 365, открытый LibreOffice/OpenOffice и облачный Google Workspace. 
Ключевые критерии: глубина и совместимость функций (особенно сложных формул и макросов в таблицах), поддержка форматов файлов (корректность открытия .docx), стоимость владения (разовые лицензии vs. подписка), возможности для совместной работы в реальном времени и интеграция с другими корпоративными системами (Active Directory, почтовые серверы).

### Цели, задачи, этапы и объекты ревьюирования
Цель код-ревью — системное улучшение качества кода и обмен знаниями. Задачи: найти логические ошибки, проверить соответствие архитектурным принципам, убедиться в читаемости и соблюдении стиля, выявить потенциальные проблемы с безопасностью или производительностью. 
Этапы: подготовка автором (описание изменений), проверка ревьюером, обсуждение (часто асинхронное), внесение правок и окончательное одобрение (approve). 
Объекты ревью — это не только исходный код, но и конфигурационные файлы, скрипты сборки, документация API и даже сообщения коммитов.

### Системы контроля версий
Системы контроля версий (VCS) — фундаментальный инструмент, который фиксирует историю изменений в файлах. Централизованные (например, SVN) используют единый сервер-репозиторий. Распределенные (Git, Mercurial) дают каждому разработчику полную локальную копию истории, что обеспечивает работу офлайн и большую гибкость. 
Помимо базовых операций (commit, push, pull), VCS позволяют эффективно управлять ветвлением и слиянием, отмечать важные точки (теги), временно "откладывать" изменения (stash) и искать причины появления ошибок (git bisect).

### Цели, корректность и направления анализа программных продуктов
Главная цель анализа — получение достоверной информации для принятия обоснованных решений о продукте. Корректность анализа обеспечивается использованием валидных методов, проверкой исходных данных и отсутствием предвзятости. Основные направления:
- Функциональный анализ: что система делает?
- Структурный анализ: как система устроена изнутри?
- Поведенческий анализ: как система реагирует на события и внешние воздействия?
- Анализ эффективности/производительности: с какой скоростью и какими ресурсами?
- Анализ надежности и безопасности.

### Планирование ревьюирования
Эффективное ревью требует подготовки. Планирование включает:
- Определение объема: ревьюировать весь коммит целиком или разбить на мелкие логические части (чем меньше, тем эффективнее).
- Выбор ревьюеров: привлечение как экспертов в предметной области, так и разработчиков, которые будут поддерживать этот код в будущем.
- Определение критериев проверки: на что обращать особое внимание (безопасность, производительность, соответствие новому API).
- Установка временных рамок: чтобы ревью не становилось "бутылочным горлышком" в процессе разработки.
Хорошее планирование делает процесс ревью предсказуемым и полезным, а не формальным и обременительным.

### Представление результатов сравнения
Итоги сравнительного анализа должны быть представлены в форме, удобной для восприятия и принятия решений. Часто используются:
- Сводные таблицы, где продукты — строки, а критерии — столбцы, с цветовым кодированием (красный/желтый/зеленый).
- Диаграммы: гистограммы для сравнения количественных показателей (производительность, цена), радарные диаграммы для многокритериальной оценки.
- Текстовый отчет с разделением на выводы, рекомендации и детальные пояснения по каждому критерию.
Важно выделить явного лидера по ключевым критериям или сценарии использования, для которых подходит каждый из продуктов.

### Проведение сравнительного анализа программных продуктов, используя механизмы контроля внесения изменений в код
Этот подход интегрирует анализ в сам процесс разработки или сопровождения продукта. Используя историю git, можно отследить, как менялись ключевые характеристики (например, время запуска, объем потребляемой памяти) от версии к версии, какие коммиты привели к улучшениям или регрессиям. Можно сравнивать разные ветки (например, экспериментальную и основную) или форки одного проекта. Это превращает сравнение из статического "снимка" в динамическое изучение эволюции продуктов.

### Выполнение оптимизации программного кода с использованием специализированных программных средств
Оптимизация — это целенаправленное изменение кода для улучшения определенных характеристик (чаще всего производительности или потребления памяти) при сохранении функциональности. 
Специализированные средства — это профилировщики (profiler), которые показывают, где программа проводит больше всего времени (CPU profiler) или выделяет память (Memory profiler). На основе этих данных ("узких мест" или bottlenecks) разработчик вносит целенаправленные изменения: оптимизирует алгоритмы, добавляет кэширование, уменьшает количество выделений памяти.

### Определение метрик программного кода специализированными средствами
Метрики кода — это количественные показатели, которые можно измерить автоматически. Специализированные средства (SonarQube, Checkstyle, PMD, ESLint) сканируют код и вычисляют метрики, такие как:
- Цикломатическая сложность (количество линейно независимых путей) — показатель тестируемости.
- Глубина наследования / число потомков — показатели сложности ООП-дизайна.
- Количество строк кода (SLOC), комментариев, их соотношение.
- Индекс поддерживаемости (Maintainability Index) — комплексный показатель.
Эти метрики дают объективную, а не субъективную, оценку качества кодовой базы и помогают выявлять проблемные модули, требующие рефакторинга.

---

## Ревьюирование

### Инструментальные средства ревьюирования
Современные инструменты выходят далеко за рамки простого просмотра патчей. Платформы вроде GitHub/GitLab Pull Requests, Gerrit или Bitbucket предоставляют интерактивный интерфейс, где можно оставлять комментарии к конкретным строкам кода, вести обсуждения, требовать изменения и ставить Approval. Они интегрируются с CI/CD системами, показывая статус прохождения тестов прямо в интерфейсе ревью. Некоторые инструменты поддерживают автоматические проверки на стиль кода или уязвимости, что облегчает работу ревьюера.

### Исследование программного кода на предмет ошибок и отклонения от алгоритма
Это основная содержательная задача код-ревью. Ревьюер проверяет, соответствует ли реализация заявленному алгоритму или техническому заданию. Он ищет классические ошибки: условия с неверными граничными значениями, неправильную обработку исключительных ситуаций (например, деление на ноль или отсутствие файла), потенциальные бесконечные циклы, ошибки в логических выражениях. Также проверяется, не отклоняется ли код от принятых в проекте архитектурных паттернов или соглашений.

### Проверка целостности программного кода
Целостность кода подразумевает его внутреннюю согласованность и полноту. Проверяется, что новый код не создает "висячих" ссылок (неиспользуемых импортов, методов, переменных), что все публичные методы и классы имеют необходимую документацию (Javadoc, XML-комментарии), что изменения в одном модуле не нарушили работу других модулей (проверяется через запуск регрессионных тестов), и что код компилируется и собирается без ошибок и предупреждений в конфигурации сборки, отличной от локальной машины разработчика.

### Программные измерительные мониторы. Применение отладчиков и дизассемблеров (OllyDbg, WinDbg, IdaPro). Защита программ от исследования

- **Измерительные мониторы (Profilers)**: инструменты для сбора данных о работе программы в реальном времени (CPU, память, I/O).
- **Отладчики (Debuggers)**: позволяют пошагово выполнять программу, наблюдать за состоянием переменных и регистров, изменять их на лету. WinDbg — мощный отладчик для Windows, GDB — для Linux.
- **Дизассемблеры/Дебагеры ** (OllyDbg, x64dbg, IDA Pro): совмещают дизассемблирование с функциями отладки, что делает их основными инструментами для реверс-инжиниринга.
- **Защита от исследования** : включает методы обфускации (запутывания кода или байт-кода), упаковки/шифрования исполняемых файлов, анти-отладочные техники (обнаружение отладчика, проверка целостности кода) для затруднения анализа.

### Метрики сложности
Метрики сложности — это числовые показатели, оценивающие сложность понимания, тестирования и поддержки кода. Самой известной является Цикломатическая сложность Маккейба, которая рассчитывается на основе графа потока управления и отражает количество тестовых сценариев, необходимых для полного покрытия пути. Высокая сложность (>10-15 для метода) сигнализирует о необходимости рефакторинга — разбиения на более простые методы. Другие метрики: глубина вложенности условий, количество параметров метода, связность (afferent/efferent coupling) модулей.

### Использование методов и технологии тестирования и ревьюирования кода и проектной документации
Это синергетический подход к обеспечению качества. 
Тестирование (юнит-тесты, интеграционные, системные) проверяет корректность поведения кода автоматически. 
Ревью кода выявляет проблемы, которые сложно поймать тестами (архитектурные решения, читаемость). Ревью проектной документации (технических заданий, архитектурных решений, UML-диаграмм) критически важен для предотвращения фундаментальных ошибок на ранних стадиях. 
`Совместное применение этих методов создает многоуровневую систему контроля качества.`

### Использование метрик программного продукта
Метрики продукта используются на всех этапах жизненного цикла. 
На этапе планирования метрики размера (например, Function Points) помогают оценить трудозатраты. Во время разработки метрики кода (сложность, покрытие тестами) контролируют техническое качество. На этапе тестирования метрики плотности дефектов и эффективности тестов оценивают прогресс. После выпуска метрики надежности (наработка на отказ) и производительности (время отклика) отслеживают качество в production. Это позволяет принимать управленческие решения, основанные на данных.

### Измерительные методы оценки программ: назначение, условия применения
**Назначение измерительных методов** — предоставить объективную, количественную основу для оценки, прогнозирования и управления процессами разработки и характеристиками продукта. Условия корректного применения:
1. Измеряемый атрибут должен быть четко определен и понятен.
2. Метод измерения должен быть воспроизводимым и давать одинаковые результаты при повторении.
3. Необходимо понимать ограничения и погрешность метода.
4. Метрика должна быть практичной — стоимость ее сбора не должна превышать пользу от ее использования.
Пример: метод подсчета строк кода (SLOC) прост, но сильно зависит от стиля программирования, поэтому его применяют с осторожностью.

### Основные методы сравнительного анализа программных продуктов и средств разработки
1. **Функциональное сравнение**: детальное сопоставление возможностей и характеристик по заранее составленному чек-листу.
2. **Бенчмаркинг** (Benchmarking): выполнение стандартизированных тестов для измерения и сравнения количественных показателей (скорость, потребление памяти).
3. **Анализ стоимости владения (TCO)**: учет не только первоначальной лицензии, но и затрат на обучение, поддержку, обновления и инфраструктуру.
4. **Изучение экосистемы и сообщества**: оценка активности разработчиков, доступности документации, форумов поддержки, количества готовых библиотек или плагинов.
5. **Пилотный проект (Pilot)**: практическое испытание продукта на реальной, но ограниченной задаче внутри организации.

### Эталоны и методы проверки корректности
**Эталоны**: это формальные спецификации, стандарты или образцовые реализации, с которыми сравнивается продукт. Например, спецификация языка SQL является эталоном для СУБД.

**Методы проверки**:
- *Верификация*: "Мы делаем систему правильно?" — проверка соответствия процесса и промежуточных артефактов планам и стандартам (ревью, статический анализ).
- *Валидация*: "Мы делаем правильную систему?" — проверка того, что готовый продукт удовлетворяет реальные потребности пользователя (тестирование, приемочные испытания, пилотная эксплуатация).
- *Формальные методы*: использование математической логики для доказательства корректности программ (например, модель проверки).

### Корректность программ
*Корректность* — фундаментальное свойство программы, означающее, что она ведет себя в точном соответствии со своей формальной спецификацией. Различают частичную корректность (если программа завершается, то результат корректен) и полную корректность (программа всегда завершается и дает корректный результат). 
Доказательство корректности — сложная задача, поэтому на практике используются приближенные методы: исчерпывающее тестирование (часто невозможно), формальная верификация (для критических систем) и комбинация тестирования, ревью и статического анализа.

### Проведение сравнительного анализа средств разработки программных продуктов
Анализ таких средств, как интегрированные среды разработки (IDE), фреймворки и библиотеки, требует особых критериев:
- **Для IDE**: скорость работы, "умные" возможности (автодополнение, рефакторинг), поддержка языка и его версий, отладчик, интеграция с системами контроля версий и CI/CD, стоимость, потребление ресурсов.
- **Для фреймворков**: кривая обучения, производительность, безопасность по умолчанию, качество документации, размер и активность сообщества, частота обновлений и обратная совместимость.
Сравнение помогает выбрать инструмент, который максимизирует продуктивность команды на конкретном проекте.

### Применение стандартных метрик по прогнозированию затрат, сроков и качества
Это область программной инженерии, связанная с оценкой (estimation). Используются модели и метрики:
- **Метод Function Points (FP)**: оценивает размер функциональности, предоставляемой пользователю, независимо от технологии. На основе FP и исторических данных модели (например, COCOMO) прогнозируют трудозатраты в человеко-месяцах.
- **Метрики, основанные на размере кода (SLOC)**: более просты, но менее точны из-за разной выразительности языков.
- **Метрики для прогноза качества**: например, модели, связывающие сложность кода (цикломатическую) или плотность комментариев с вероятным количеством дефектов.
Использование этих метрик требует калибровки на основе исторических данных конкретной организации.

### Метрики, направления применения метрик
*Метрики* — это инструмент измерения. Их применение многогранно:
- **Управление проектом**: отслеживание прогресса (выполнено story points), прогнозирование сроков завершения.
- **Контроль качества продукта** : мониторинг уровня дефектов, покрытия тестами, сложности кода.
- **Управление процессом** : оценка эффективности методологий (например, время цикла от коммита до продакшена), выявление "узких мест".
- **Технический менеджмент** : выявление модулей с высокой сложностью и низкой связанностью для приоритетного рефакторинга.
- **Сравнительный анализ** : объективное сравнение продуктов, инструментов или производительности команд.

### Использование метрик стилистики
Стилистические метрики оценивают не "что делает код", а "как он написан". Их цель — обеспечить единообразие, что повышает читаемость и снижает когнитивную нагрузку при работе в команде. Примеры:
- Длина строки (максимально допустимое количество символов).
- Глубина отступов / вложенности.
- Правила именования (camelCase, snake_case для разных типов сущностей).
- Правила расстановки пробелов и скобок.
Инструменты вроде Checkstyle, ESLint, Prettier могут автоматически проверять и даже исправлять нарушения этих метрик.

### Выполнение измерений характеристик кода в среде (например, Eclipse C/C++ и др.)
Современные IDE предлагают встроенные или подключаемые средства для анализа кода. В Eclipse с плагинами для C/C++ (например, CDT) можно использовать встроенные статические анализаторы для поиска потенциальных ошибок. Плагины для метрик (например, Metrics2, Eclipse MoDisco) позволяют вычислять цикломатическую сложность, связность и другие показатели прямо в среде разработки. Профилировщики, интегрированные в IDE, позволяют измерять производительность и потребление памяти без переключения между приложениями. Это обеспечивает быструю обратную связь для разработчика.

### Выполнение измерений характеристик кода в среде VisualStudio
Visual Studio предоставляет мощный набор встроенных инструментов для анализа:
- **Анализаторы кода (Code Analysis)** : выполняют статический анализ на соответствие правилам Microsoft (например, SEH, SAL) и выявляют потенциальные проблемы с безопасностью, производительностью и надежностью.
- **Профилировщики производительности** : инструменты для анализа использования ЦПУ, памяти, GPU и ввода-вывода. Позволяют находить "горячие" точки (hot paths) в коде.
- **Инструменты диагностики** : для отладки утечек памяти, анализа дампов памяти.
- **Расчет метрик кода** : встроенная функция для вычисления показателей сложности и поддерживаемости.
Интеграция этих инструментов в IDE делает процесс измерения и оптимизации seamless.

### Современные стандарты качества программного продукта и процессов его обеспечения
Это набор международных и отраслевых стандартов, задающих рамки для создания качественного ПО.
- **ISO/IEC 25000 (SQuaRE)** : всеобъемлющая серия стандартов, посвященная качеству программного продукта и его оценке. Определяет модель качества, состоящую из характеристик (функциональность, надежность, удобство использования и др.) и подхарактеристик.
- **ISO/IEC 12207** : стандарт процессов жизненного цикла ПО.
- **CMMI (Capability Maturity Model Integration)**: модель зрелости процессов в организации (уровни от 1 до 5).
- **SPICE (ISO/IEC 15504)**: стандарт для оценки процессов.
Следование этим стандартам помогает организациям систематизировать свою работу, улучшать процессы и демонстрировать уровень зрелости заказчикам.

---

## Основные категории моделирования и анализа ПО.

- Статистический анализ
Цель — обнаружить потенциальные ошибки, уязвимости, нарушения стиля кодирования и другие проблемы, которые могут привести к багам или снижению производительности программы. Н-р: PMD, StyleCop, SonarQube и т.д.

- Динамический анализ
Исследует программу во время её фактического выполнения. В отличии от статического метода позволяет обнаружить проблемы, которые появляются только при запуске. Н-р: Valgrind, JProfiler, AppDynamics и т.д.

- Тестирование
Проверяет соответствие работы ПО требования на наборе заранее подобранных ситуаций. Н-р: Selenium, Postman, JMeter и т.д.

- Безопасность
Помогает выявить уязвимые места ПО, которые могут быть использованы злоумышленниками. Н-р: QWASP ZAP, Snyk, Checkmarx и т.д.

## Метрики анализа:
- Цикломатическая сложность;
- Коэффициент связности;
- Коэффициент надёжности;
- Время отклика.

## Основные модели и нотации (языки моделирования)

### *UML (Unified Modeling Language)* - основной стандарт. Делится на 2 группы:

#### 1. Структурные диаграммы
- Диаграммы классов (Class Diagram)
- Диаграмма компонентов (Component Diagram)
- Диаграмма развертывания (Deployment Diagram)

#### 2. Поведенческие диаграммы 
- Диаграмма вариантов использования (Use Case Diagram)
- Диаграмма последовательности (Sequence Diagram)
- Диаграмма деятельности (Activity Diagram)
- Диаграмма состояний (State Machine Diagram)

### Особенности :
- Основан на строгом наборе символов.
- Помогает визуально отразить процессы в едином формате и понятном для всех.
- Не является языком программирования, но на основании UML- моделей возможна генерация кода.

### Инструменты (TOML)
- Проектирование и диаграммы:
Enterprise Architect, Visual Paradigm, Miro
- Управление требованиями:
Jira, Confluence, Youtrack
- Прототипирование:
Figma, Adobe XD

### Этапы работы с моделями (По шагам)
1. Шаг: Вопрос
Задаём чёткий вопрос.
2. Шаг: Выбор инструмента
В зависимости от вопроса выбираем тип модели.
3. Шаг: Создание схемы
Рисуем модель в выбранном инструменте.
4. Шаг: Проверка и анализ
Проверяем модель на корректность и проводим анализ.
5. Шаг: Выводы и решения
На основе анализа принимаем решения.

### Выбор подхода:
- Гибкий (Agile) - точечно, быстро.
- Документированный (Waterfall) - полный цикл моделирования и утверждения ТЗ/диаграмм перед стартом разработки.
